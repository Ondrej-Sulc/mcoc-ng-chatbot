// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

// --- Enums for type safety and consistency ---
enum ChampionClass {
  SCIENCE
  SKILL
  MYSTIC
  COSMIC
  TECH
  MUTANT
  SUPERIOR
}

enum AbilityLinkType {
  ABILITY
  IMMUNITY
}

// NEW: Enum for the different attack types.
enum AttackType {
  L1
  L2
  L3
  L4
  M1
  M2
  H
  S1
  S2
}

enum WarVideoStatus {
  PLANNING
  UPLOADED
  PUBLISHED
  REJECTED
}

// --- Models ---

// RENAMED from GlossaryCategory and re-linked
model AbilityCategory {
  id          Int    @id @default(autoincrement())
  name        String @unique
  description String

  abilities Ability[]
}

model Ability {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  emoji       String?

  categories AbilityCategory[]
  champions  ChampionAbilityLink[]
}

model Champion {
  id            Int           @id @default(autoincrement())
  name          String        @unique
  shortName     String
  class         ChampionClass
  releaseDate   DateTime
  obtainable    String[]
  prestige      Json
  images        Json
  discordEmoji  String?
  fullAbilities Json

  // --- Relations ---
  tags               Tag[]
  abilities          ChampionAbilityLink[]
  attacks            Attack[]
  roster             Roster[]
  synergyProviderFor ChampionAbilitySynergy[]
  duels              Duel[]
  asAttacker         WarFight[]    @relation("AttackerRelation")
  asDefender         WarFight[]    @relation("DefenderRelation")
  usedAsPrefight     WarFight[]    @relation("PrefightChampions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Duel {
  id         Int      @id @default(autoincrement())
  playerName String
  rank       String?

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([championId])
}

model Tag {
  id       Int    @id @default(autoincrement())
  name     String
  category String

  champions Champion[]

  @@unique([name, category])
}

model ChampionAbilityLink {
  id     Int             @id @default(autoincrement())
  type   AbilityLinkType
  source String?

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  abilityId Int
  ability   Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  synergyChampions ChampionAbilitySynergy[]

  @@unique([championId, abilityId, type, source])
  @@index([championId])
  @@index([abilityId])
}

model ChampionAbilitySynergy {
  id                    Int                 @id @default(autoincrement())
  championAbilityLinkId Int
  championAbilityLink   ChampionAbilityLink @relation(fields: [championAbilityLinkId], references: [id], onDelete: Cascade)
  championId            Int
  champion              Champion            @relation(fields: [championId], references: [id], onDelete: Cascade)

  @@unique([championAbilityLinkId, championId])
  @@index([championAbilityLinkId])
  @@index([championId])
}

// --- New Models for Normalized Attacks ---

// Represents a specific attack for a champion (e.g., Abomination's SP2)
model Attack {
  id   Int        @id @default(autoincrement())
  type AttackType // e.g., S1, M2, etc.

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  hits Hit[] // An attack is composed of one or more hits

  @@unique([championId, type]) // Each champion can only have one S1, one M1, etc.
  @@index([championId])
}

// Represents a single hit within an attack.
model Hit {
  id         Int      @id @default(autoincrement())
  properties String[] // e.g., ["Contact", "Physical"]

  attackId Int
  attack   Attack @relation(fields: [attackId], references: [id], onDelete: Cascade)

  @@index([attackId])
}

enum ScheduleFrequency {
  daily
  weekly
  monthly
  every
}

model Schedule {
  id                String            @id @default(cuid())
  name              String
  frequency         ScheduleFrequency
  time              String
  command           String?
  message           String?
  target_channel_id String?
  target_user_id    String?
  is_active         Boolean           @default(true)
  day               String?
  interval          String?
  unit              String?
  last_run          DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AQState {
  channelId String   @id
  state     Json
  updatedAt DateTime @updatedAt
}

// --- Player and Prestige Logging ---

model Player {
  id                 String    @id @default(cuid())
  discordId          String
  ingameName         String
  isActive           Boolean   @default(false)
  timezone           String?
  isTrustedUploader  Boolean   @default(false)

  summonerPrestige Int?
  championPrestige Int?
  relicPrestige    Int?
  isBotAdmin       Boolean   @default(false)
  isOfficer        Boolean   @default(false)
  battlegroup      Int?

  roster          Roster[]
  prestigeHistory PrestigeLog[]
  uploadTokens    UploadToken[]

  alliance   Alliance? @relation(fields: [allianceId], references: [id], onDelete: SetNull)
  allianceId String?

  playedInFights  WarFight[] @relation("PlayerInFight")
  submittedVideos WarVideo[] @relation("SubmittedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([discordId, ingameName])
  @@index([discordId])
  @@index([allianceId])
}

model PrestigeLog {
  id               Int      @id @default(autoincrement())
  summonerPrestige Int
  championPrestige Int
  relicPrestige    Int
  createdAt        DateTime @default(now())

  player   Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId String

  @@index([playerId])
}

model Alliance {
  id               String   @id @default(cuid())
  guildId          String   @unique
  name             String
  enabledFeatureCommands  String[] @default([])
  createAqThread   Boolean  @default(false)
  officerRole      String?
  battlegroup1Role String?
  battlegroup2Role String?
  battlegroup3Role String?

  members Player[]
  config  AllianceConfig?
  aqSchedules AQSchedule[]
  aqSkip      AQSkip?
  aqReminderSettings AQReminderSettings?
  wars               War[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AQReminderSettings {
  id          String   @id @default(cuid())
  alliance    Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId  String   @unique

  section1ReminderEnabled Boolean @default(true)
  section1PingTime        String  @default("11:00")

  section2ReminderEnabled Boolean @default(true)
  section2PingTime        String  @default("18:00")

  finalReminderEnabled    Boolean @default(true)
  finalPingTime           String  @default("11:00")
}

model AllianceConfig {
  id          String  @id @default(cuid())
  sheetId     String?

  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String   @unique
}

model AQSchedule {
  id          String   @id @default(cuid())
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String
  battlegroup Int
  dayOfWeek   Int // 0 = Sunday, 6 = Saturday
  time        String // "HH:mm"
  aqDay       Int
  channelId   String
  roleId      String

  @@unique([allianceId, battlegroup, aqDay])
}

model AQSkip {
  id         String   @id @default(cuid())
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String   @unique
  skipUntil  DateTime
}

model Roster {
  id          String  @id @default(cuid())
  stars       Int
  rank        Int
  isAwakened  Boolean
  isAscended  Boolean @default(false)
  powerRating Int?

  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId   String
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)
  championId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([playerId, championId, stars])
  @@index([playerId])
  @@index([championId])
}

// --- War Video Models ---

model War {
  id             String   @id @default(cuid())
  season         Int
  warNumber      Int?
  warTier        Int
  enemyAlliance  String?
  createdAt      DateTime @default(now())

  // A war belongs to an alliance
  allianceId String
  alliance   Alliance @relation(fields: [allianceId], references: [id])

  // A war is comprised of many fights
  fights WarFight[]

  @@unique([allianceId, season, warNumber])
  @@index([allianceId])
}

model WarFight {
  id          String   @id @default(cuid())
  death       Boolean
  createdAt   DateTime @default(now())

  // --- Core Fight Details ---
  attackerId Int
  attacker   Champion @relation("AttackerRelation", fields: [attackerId], references: [id])
  defenderId Int
  defender   Champion @relation("DefenderRelation", fields: [defenderId], references: [id])
  nodeId     Int
  node       WarNode  @relation(fields: [nodeId], references: [id])

  prefightChampions Champion[] @relation("PrefightChampions")

  // --- Contextual Links ---
  // The player who performed the fight
  playerId String
  player   Player @relation("PlayerInFight", fields: [playerId], references: [id])

  // The war this fight belongs to
  warId String
  war   War @relation(fields: [warId], references: [id], onDelete: Cascade)

  // The video this fight appears in (optional, can be null)
  videoId String?
  video   WarVideo? @relation(fields: [videoId], references: [id], onDelete: SetNull)

  @@unique([warId, playerId, nodeId])
  @@index([attackerId])
  @@index([defenderId])
  @@index([nodeId])
  @@index([playerId])
  @@index([warId])
  @@index([videoId])
}

model WarVideo {
  id          String         @id @default(cuid())
  gcsUrl      String?        @unique
  url         String?        @unique
  description String?
  visibility  String         @default("public")
  status      WarVideoStatus @default(PLANNING)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // A video can contain one or more fights
  fights WarFight[]

  // The player who submitted the video
  submittedById String
  submittedBy   Player @relation("SubmittedBy", fields: [submittedById], references: [id])

  @@index([submittedById])
}

model WarNode {
  id          Int        @id @default(autoincrement())
  nodeNumber  Int        @unique
  description String?
  fights      WarFight[]
}

model UploadSession {
  id        String   @id @default(cuid())
  token     String   @unique
  fightIds  String[]
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model UploadToken {
  id        String   @id @default(cuid())
  token     String   @unique
  playerId  String
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([playerId])
}